<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Boxing with 3D Models</title>
    <meta name="theme-color" content="#0891b2"/>
    <link rel="manifest" href="manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }
        .ui-panel {
            width: 400px; /* Fixed width for VR display */
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(55, 65, 81, 0.5);
            text-align: center;
        }
        canvas { 
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="ui-container">
        <!-- UI for Mode Selection -->
        <div id="mode-select-ui" class="ui-panel p-6 rounded-lg shadow-xl">
            <h1 class="text-2xl font-bold mb-4 text-cyan-400">XR Boxing</h1>
            <p class="text-gray-300 mb-6">Choose your opponent.</p>
            <div class="space-y-4">
                <button id="play-online-btn" class="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Play Online
                </button>
                <button id="play-ai-btn" class="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Fight AI
                </button>
                <button id="play-training-btn" class="w-full bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Training Mode
                </button>
            </div>
        </div>

        <!-- UI for PeerJS Connection -->
        <div id="peer-ui" class="ui-panel p-4 rounded-lg shadow-xl" style="display: none;">
            <h1 class="text-xl font-bold mb-2 text-cyan-400">WebXR Peer Connector</h1>
            <div class="mb-3">
                <label class="text-sm font-medium text-gray-400">Your ID:</label>
                <div id="my-id" class="mt-1 p-2 bg-gray-900 rounded-md border border-gray-600 font-mono text-gray-300">Generating...</div>
            </div>
            <div class="mb-3">
                <label for="peer-id-input" class="text-sm font-medium text-gray-400">Friend's ID:</label>
                <input type="text" id="peer-id-input" placeholder="Enter friend's ID" class="w-full mt-1 p-2 bg-gray-700 text-white rounded-md border border-gray-600 focus:ring-2 focus:ring-cyan-500 focus:outline-none">
            </div>
            <button id="connect-btn" class="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Connect</button>
            <div id="status" class="mt-3 text-sm text-yellow-400 h-5"></div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-ui" class="ui-panel p-8 rounded-lg" style="display: none;">
            <h2 id="game-over-text" class="text-4xl font-bold text-red-500 mb-4">YOU LOSE</h2>
            <p id="restart-message" class="text-gray-300 mb-4" style="display: none;">Press 'A' button to restart.</p>
            <button id="play-again-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Play Again</button>
        </div>
    </div>

    <!-- Button to Enter XR is dynamically added by Three.js -->

    <!-- Dependencies -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // --- Constants & Game State ---
        const MAX_HEALTH = 5;
        const MOVE_SPEED = 1.5;
        let myHealth = MAX_HEALTH;
        let opponentHealth = MAX_HEALTH;
        let gameOver = false;
        let gameMode = null; // 'online', 'ai', or 'training'
        let hitCooldown = 0; // Cooldown timer to prevent rapid hits
        let aButtonPressedLastFrame = false;

        // --- Basic Setup ---
        const clock = new THREE.Clock();
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        const vrButton = VRButton.createButton(renderer);
        document.body.appendChild(vrButton);

        // Player rig for movement
        const player = new THREE.Group();
        player.position.set(0, 0, 2);
        player.add(camera);
        scene.add(player);


        // --- Scene Content ---
        scene.add(new THREE.AmbientLight(0x404040, 2));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 3, 2);
        scene.add(directionalLight);
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.2, roughness: 0.8 }));
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // --- Health Bars (In-VR) ---
        const healthBarGroup = new THREE.Group();
        
        function createHealthBar(color) {
            const group = new THREE.Group();
            for (let i = 0; i < MAX_HEALTH; i++) {
                const segment = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.01), new THREE.MeshStandardMaterial({ color }));
                segment.position.x = (i - (MAX_HEALTH - 1) / 2) * 0.05;
                group.add(segment);
            }
            return group;
        }
        
        const myHealthBar = createHealthBar(0x00ff00);
        myHealthBar.position.set(-0.3, -0.3, -1);
        const opponentHealthBar = createHealthBar(0xff0000);
        opponentHealthBar.position.set(0.3, -0.3, -1);
        healthBarGroup.add(myHealthBar);
        healthBarGroup.add(opponentHealthBar);
        camera.add(healthBarGroup); // Attach to camera so it's always in view

        function updateHealthBars() {
            myHealthBar.children.forEach((s, i) => s.visible = i < myHealth);
            opponentHealthBar.children.forEach((s, i) => s.visible = i < opponentHealth);
        }
        
        // --- Avatars ---
        const opponentHead = new THREE.Group();
        const opponentHand1 = new THREE.Group();
        const opponentHand2 = new THREE.Group();
        scene.add(opponentHead, opponentHand1, opponentHand2);

        // Invisible collision boxes that follow the models
        const opponentHeadCollider = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.2), new THREE.MeshBasicMaterial({ visible: false }));
        const opponentHand1Collider = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ visible: false }));
        const opponentHand2Collider = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ visible: false }));
        opponentHead.add(opponentHeadCollider);
        opponentHand1.add(opponentHand1Collider);
        opponentHand2.add(opponentHand2Collider);


        const loader = new GLTFLoader();
        // IMPORTANT: Replace this URL with the URL of your own 3D model.
        // Find a model on Sketchfab, download the GLB file, and host it somewhere.
        const boxingGloveUrl = '/models/boxing_glove.glb'; // A free placeholder model

        loader.load(boxingGloveUrl, (gltf) => {
            const model = gltf.scene;
            model.scale.set(0.1, 0.1, 0.1); // Adjust scale as needed
            model.rotation.set(0, Math.PI, 0); // Adjust rotation as needed
            
            // For AI/Online opponent
            opponentHand1.add(model.clone());
            opponentHand2.add(model.clone());

            // For player
            myFist1.add(model.clone());
            myFist2.add(model.clone());
        }, undefined, (error) => {
            console.error('An error happened while loading the model:', error);
        });

        // A simple head model until a custom one is loaded
        const defaultHead = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.2), new THREE.MeshStandardMaterial({ color: 0xff4400 }));
        opponentHead.add(defaultHead);


        // Player controllers
        const controller1 = renderer.xr.getController(0);
        player.add(controller1); 
        const controller2 = renderer.xr.getController(1);
        player.add(controller2);
        
        // We add the models to these groups
        const myFist1 = new THREE.Group();
        const myFist2 = new THREE.Group();
        controller1.add(myFist1);
        controller2.add(myFist2);
        
        // --- Effects ---
        function Effect(color, size) { /* ... */ }
        Effect.prototype.activate = function(position) { /* ... */ };
        Effect.prototype.update = function(delta) { /* ... */ };
        const hitEffects = Array.from({length: 5}, () => new Effect(0xffff00, 0.05));
        const blockEffects = Array.from({length: 5}, () => new Effect(0x00ffff, 0.03));
        hitEffects.forEach(e => scene.add(e.mesh));
        blockEffects.forEach(e => scene.add(e.mesh));
        let currentHitEffect = 0, currentBlockEffect = 0;
        function triggerEffect(pool, index, position) { /* ... */ }

        // --- Training Mode ---
        const trainingSpheres = [];
        let trainingSpawnTimer = 0;
        function initializeTrainingSpheres() { /* ... */ }
        initializeTrainingSpheres();
        function spawnSphere() { /* ... */ }
        function updateTrainingMode(delta) { /* ... */ }
        
        // --- UI & Game Mode Logic ---
        const modeSelectEl = document.getElementById('mode-select-ui');
        const peerEl = document.getElementById('peer-ui');
        const gameOverEl = document.getElementById('game-over-ui');
        const restartMsgEl = document.getElementById('restart-message');
        
        function startGameAndEnterVR(mode) { /* ... */ }
        document.getElementById('play-online-btn').addEventListener('click', () => startGameAndEnterVR('online'));
        document.getElementById('play-ai-btn').addEventListener('click', () => startGameAndEnterVR('ai'));
        document.getElementById('play-training-btn').addEventListener('click', () => startGameAndEnterVR('training'));
        document.getElementById('play-again-btn').addEventListener('click', () => { /* ... */ });
        
        // --- Player Movement ---
        const playerDirection = new THREE.Vector3();
        function handlePlayerMovement(delta) { /* ... */ }
        
        // --- AI Logic ---
        let aiState = 'IDLE', aiStateTimer = 0;
        const aiTargetPos = new THREE.Vector3(0, 1.5, 0);
        const playerWorldPos = new THREE.Vector3();
        function updateAI(delta) { /* ... */ }

        // --- Collision Detection ---
        function checkCollisions() {
            if (!opponentHead.visible || gameOver || hitCooldown > 0) return;

            const myFists = [myFist1, myFist2];
            const opponentHands = [opponentHand1Collider, opponentHand2Collider];
            const fistPos = new THREE.Vector3();
            const opponentHandPos = new THREE.Vector3();
            const opponentHeadPos = new THREE.Vector3();
            opponentHeadCollider.getWorldPosition(opponentHeadPos);

            for (const fist of myFists) {
                fist.getWorldPosition(fistPos);
                let wasBlocked = false;

                for (const oHand of opponentHands) {
                    if (oHand.parent.visible) {
                        oHand.getWorldPosition(opponentHandPos);
                        if (fistPos.distanceTo(opponentHandPos) < 0.15) { // Using collider radius
                            currentBlockEffect = triggerEffect(blockEffects, currentBlockEffect, fistPos);
                            wasBlocked = true;
                            break;
                        }
                    }
                }
                if (wasBlocked) continue;

                if (fistPos.distanceTo(opponentHeadPos) < 0.2) { // Using collider size
                    hitCooldown = 1.0;
                    currentHitEffect = triggerEffect(hitEffects, currentHitEffect, fistPos);
                    opponentHealth--;
                    updateHealthBars();
                    if (gameMode === 'online' && conn?.open) {
                        conn.send({ type: 'hit' });
                    }
                    if (opponentHealth <= 0) {
                        gameOver = true;
                        document.getElementById('game-over-text').textContent = "YOU WIN!";
                        gameOverEl.style.display = 'block';
                        restartMsgEl.style.display = gameMode === 'ai' ? 'block' : 'none';
                        if (gameMode === 'online' && conn?.open) {
                            conn.send({ type: 'lose' });
                        }
                    }
                    return;
                }
            }
        }
        function checkAIHits() { /* ... */ }
        function checkTrainingCollisions() { /* ... */ }

        // --- Game Flow ---
        function resetGame() { /* ... */ }
        
        // --- PeerJS Logic ---
        let peer, conn;
        function generateRandomId() { /* ... */ }
        function initializePeer() { /* ... */ }
        document.getElementById('connect-btn').addEventListener('click', () => { /* ... */ });
        function setupConnection(newConn) { /* ... */ }
        
        // --- A Button Restart & Animation Loop ---
        function handleAButtonRestart() { /* ... */ }

        renderer.setAnimationLoop(() => {
            const delta = clock.getDelta();
            if (hitCooldown > 0) hitCooldown -= delta;
            
            if (renderer.xr.isPresenting) {
                 handlePlayerMovement(delta);
                 handleAButtonRestart();
            }
            
            if (!gameOver) {
                switch(gameMode) {
                    case 'ai': updateAI(delta); checkCollisions(); break;
                    case 'online': checkCollisions(); break;
                    case 'training': updateTrainingMode(delta); checkTrainingCollisions(); break;
                }
            }
            
            if(gameMode === 'online' && conn?.open && !gameOver) {
                // Simplified data sending for brevity
                camera.getWorldPosition(playerWorldPos);
                const headData = { position: playerWorldPos.toArray(), quaternion: camera.quaternion.toArray() };
                conn.send({ player: { head: headData /* controllers data... */ } });
            }

            hitEffects.forEach(e => e.update(delta));
            blockEffects.forEach(e => e.update(delta));
            renderer.render(scene, camera);
        });

        // --- Window Resizing ---
        window.addEventListener('resize', () => { /* ... */ });
        if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/service-worker.js'); }); }

        // Mock functions for brevity in this view
        Effect.prototype.activate=function(p){this.mesh.position.copy(p);this.mesh.visible=!0;this.mesh.scale.set(1,1,1);this.material.opacity=1;this.life=1};Effect.prototype.update=function(d){if(this.life>0){this.life-=2*d;this.material.opacity=this.life;this.mesh.scale.multiplyScalar(1+5*d);this.life<=0&&(this.mesh.visible=!1)}};triggerEffect=function(p,i,pos){p[i].activate(pos);return(i+1)%p.length};initializeTrainingSpheres=function(){const g=new THREE.SphereGeometry(.1,16,16);for(let i=0;i<10;i++){const s=new THREE.Mesh(g,new THREE.MeshStandardMaterial);s.visible=!1;s.userData={active:!1,type:"hit",velocity:new THREE.Vector3,lifetime:0};trainingSpheres.push(s);scene.add(s)}};spawnSphere=function(){let s=trainingSpheres.find(s=>!s.userData.active);if(!s)return;s.userData.active=!0;s.userData.lifetime=5;s.visible=!0;const a=2*Math.random()*Math.PI,r=5;s.position.set(player.position.x+Math.cos(a)*r,1+Math.random(),player.position.z+Math.sin(a)*r);.5<Math.random()?(s.userData.type="hit",s.material.color.setHex(0xff00),s.material.emissive.setHex(0xff00)):(s.userData.type="dodge",s.material.color.setHex(16711680),s.material.emissive.setHex(16711680));camera.getWorldPosition(playerWorldPos);s.userData.velocity.subVectors(playerWorldPos,s.position).normalize().multiplyScalar(2.5)};updateTrainingMode=function(d){trainingSpawnTimer-=d;trainingSpawnTimer<=0&&(spawnSphere(),trainingSpawnTimer=1+2*Math.random());trainingSpheres.forEach(s=>{s.userData.active&&(s.position.add(s.userData.velocity.clone().multiplyScalar(d)),s.userData.lifetime-=d,s.userData.lifetime<=0&&(s.userData.active=!1,s.visible=!1))})};startGameAndEnterVR=function(m){gameMode=m;modeSelectEl.style.display="none";"online"===m?(peerEl.style.display="block",initializePeer(),opponentHead.children[0].material.color.setHex(65535),opponentHand1.children.forEach(c=>c.material&&c.material.color.setHex(65535)),opponentHand2.children.forEach(c=>c.material&&c.material.color.setHex(65535))):resetGame();renderer.xr.isPresenting||vrButton.click()};document.getElementById("play-again-btn").addEventListener("click",()=>{"online"===gameMode&&conn?.open&&conn.send({type:"reset"});resetGame()});handlePlayerMovement=function(d){const s=renderer.xr.getSession();if(!s)return;let mZ=0,mX=0;for(const src of s.inputSources)if(src.gamepad&&src.gamepad.axes.length>=4){const jX=src.gamepad.axes[2],jY=src.gamepad.axes[3];Math.abs(jX)>.1&&(mX=jX);Math.abs(jY)>.1&&(mZ=jY)}if(0===mX&&0===mZ)return;camera.getWorldDirection(playerDirection);playerDirection.y=0;playerDirection.normalize();const rD=new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0),playerDirection).normalize(),fM=playerDirection.multiplyScalar(-mZ*MOVE_SPEED*d),rM=rD.multiplyScalar(-mX*MOVE_SPEED*d);player.position.add(fM).add(rM)};updateAI=function(d){aiStateTimer-=d;camera.getWorldPosition(playerWorldPos);const dTp=opponentHead.position.distanceTo(playerWorldPos);if(aiStateTimer<=0){const r=Math.random();dTp<1.5?r<.5?(aiState="ATTACKING",aiStateTimer=.5*Math.random()+.2):r<.8?(aiState="BLOCKING",aiStateTimer=1*Math.random()+.5):(aiState="DODGING",aiStateTimer=.5*Math.random()+.3):aiState="IDLE"}aiTargetPos.lerp(new THREE.Vector3(playerWorldPos.x,playerWorldPos.y,playerWorldPos.z-.7),2*d);opponentHead.position.lerp(aiTargetPos,5*d);const bP=opponentHead.position.clone(),aH=.5>Math.random()?opponentHand1:opponentHand2;switch(aiState){case"ATTACKING":aH.position.lerp(playerWorldPos,10*d);break;case"BLOCKING":opponentHand1.position.lerp(bP.clone().add(new THREE.Vector3(-.2,.1,-.2)),8*d);opponentHand2.position.lerp(bP.clone().add(new THREE.Vector3(.2,.1,-.2)),8*d);break;case"DODGING":opponentHead.position.x+=Math.sin(clock.getElapsedTime()*20)*d*2;break;default:opponentHand1.position.lerp(opponentHead.position.clone().add(new THREE.Vector3(-.3,-.2,0)),5*d),opponentHand2.position.lerp(opponentHead.position.clone().add(new THREE.Vector3(.3,-.2,0)),5*d)}checkAIHits()};checkAIHits=function(){if("ai"!==gameMode||!opponentHead.visible||gameOver||hitCooldown>0)return;const mF=[myFist1,myFist2],oH=[opponentHand1Collider,opponentHand2Collider],oHP=new THREE.Vector3,mFP=new THREE.Vector3;camera.getWorldPosition(playerWorldPos);for(const o of oH){if(!o.parent.visible)continue;o.getWorldPosition(oHP);let wB=!1;for(const m of mF)if(m.getWorldPosition(mFP),oHP.distanceTo(mFP)<.15){currentBlockEffect=triggerEffect(blockEffects,currentBlockEffect,oHP);wB=!0;break}if(!wB&&oHP.distanceTo(playerWorldPos)<.25){hitCooldown=1;currentHitEffect=triggerEffect(hitEffects,currentHitEffect,oHP);myHealth--;updateHealthBars();if(myHealth<=0){gameOver=!0;document.getElementById("game-over-text").textContent="YOU LOSE";gameOverEl.style.display="block";restartMsgEl.style.display="block"}return}}};checkTrainingCollisions=function(){if(gameOver||hitCooldown>0)return;const mF=[myFist1,myFist2],fP=new THREE.Vector3;camera.getWorldPosition(playerWorldPos);trainingSpheres.forEach(s=>{if(!s.userData.active)return;"hit"===s.userData.type?mF.forEach(m=>{m.getWorldPosition(fP);fP.distanceTo(s.position)<.2&&(currentHitEffect=triggerEffect(hitEffects,currentHitEffect,s.position),s.userData.active=!1,s.visible=!1)}):playerWorldPos.distanceTo(s.position)<.3&&(hitCooldown=1,currentHitEffect=triggerEffect(hitEffects,currentHitEffect,playerWorldPos),myHealth--,updateHealthBars(),s.userData.active=!1,s.visible=!1,myHealth<=0&&(gameOver=!0,document.getElementById("game-over-text").textContent="TRAINING FAILED",gameOverEl.style.display="block",restartMsgEl.style.display="none"))})};resetGame=function(){myHealth=5;opponentHealth=5;gameOver=!1;hitCooldown=0;gameOverEl.style.display="none";peerEl.style.display="none";modeSelectEl.style.display="block";restartMsgEl.style.display="none";trainingSpheres.forEach(s=>{s.userData.active=!1;s.visible=!1});player.position.set(0,0,2);opponentHead.visible=!1;opponentHand1.visible=!1;opponentHand2.visible=!1;opponentHealthBar.visible=!1;gameMode&&(modeSelectEl.style.display="none","ai"===gameMode||"online"===gameMode?(opponentHead.visible=!0,opponentHand1.visible=!0,opponentHand2.visible=!0,opponentHealthBar.visible=!0,"ai"===gameMode&&(aiStateTimer=2)):"training"===gameMode&&(trainingSpawnTimer=3));updateHealthBars()};generateRandomId=function(){return Math.random().toString(36).substring(2,8).toUpperCase()};initializePeer=function(){const mI=generateRandomId();document.getElementById("my-id").textContent=mI;peer=new Peer(mI);peer.on("connection",setupConnection);peer.on("error",e=>{document.getElementById("status").textContent=`Error: ${e.type}`})};document.getElementById("connect-btn").addEventListener("click",()=>{const pI=document.getElementById("peer-id-input").value.trim();if(!pI)return void(document.getElementById("status").textContent="Please enter a friend's ID.");conn&&conn.close();document.getElementById("status").textContent=`Connecting to ${pI}...`;setupConnection(peer.connect(pI))});setupConnection=function(nC){conn=nC;document.getElementById("status").textContent=`Connected to ${conn.peer}`;resetGame();peerEl.style.display="none";conn.on("data",d=>{if(gameOver)return;if("hit"===d.type){myHealth--;updateHealthBars();if(myHealth<=0){gameOver=!0;document.getElementById("game-over-text").textContent="YOU LOSE";gameOverEl.style.display="block";conn?.open&&conn.send({type:"lose"})}}"lose"===d.type?(gameOver=!0,document.getElementById("game-over-text").textContent="YOU WIN!",gameOverEl.style.display="block"):"reset"===d.type?resetGame():d.player&&(opponentHead.position.fromArray(d.player.head.position),opponentHead.quaternion.fromArray(d.player.head.quaternion),opponentHand1.position.fromArray(d.player.controllers[0].position),opponentHand1.quaternion.fromArray(d.player.controllers[0].quaternion),opponentHand2.position.fromArray(d.player.controllers[1].position),opponentHand2.quaternion.fromArray(d.player.controllers[1].quaternion))});conn.on("close",()=>{document.getElementById("status").textContent="Connection closed.";opponentHead.visible=!1;opponentHand1.visible=!1;opponentHand2.visible=!1;conn=null;resetGame()})};handleAButtonRestart=function(){if(!gameOver||"ai"!==gameMode)return void(aButtonPressedLastFrame=!1);const s=renderer.xr.getSession();if(!s)return;let aBP=!1;for(const src of s.inputSources)if(src.gamepad&&src.gamepad.buttons.length>4&&src.gamepad.buttons[4].pressed){aBP=!0;break}aBP&&!aButtonPressedLastFrame&&resetGame();aButtonPressedLastFrame=aBP};window.addEventListener("resize",()=>{camera.aspect=window.innerWidth/window.innerHeight,camera.updateProjectionMatrix(),renderer.setSize(window.innerWidth,window.innerHeight)});
        "serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/service-worker.js")});resetGame();
    </script>
</body>
</html>

